
Vision:
=======
A 3D world to explore and visualise customer data.



Target of current iteration:
============================
1 - Define what we want from the application
2 - Deliver tech demos on all the areas.



App Outline
===========
- 3D Globe - Dynamically loading
    - Demos smooth tile loading, minimum VRAM burden
    - New LOD levels, load textures later.
    - New decimated mesh, geometry saved in database.

- Camera controls
    - World view
    - Chase cam

- Entity Data
    - List entities
    - Show pos/speed
    - Show Element summary

- Control
    - Settings
    - Network
    - CLI



Immediate Task (Define a task - focus on delivering it):
=========================================================

Assessment:
- MiniMesh has been very good in defining new options of OBJ/MTL edits with Blender, and then import/export from the code.
- ColorMesh has been very good at defining new minimal surface mesh options. Good mesh creation and serialisation options.

- ColorMesh, plus a number of optimisations around serialisation size and tile creation, does not deliver the required level
  of performance and quality.
    - The RAM usage it too high, even after optimisations. The visual compromise needs to deliver a 100x improvement elsewhere. 
        - Can't just trade VRAM for RAM usage.
    - The step changes in resolution are too high for a consistent aesthetic. This would need a tile-code rework into a b-tree.
        - This is a whole rework of tilecode, map tiles, everything.

Ideas:
- We have an elevation system that can load anything with a range and resolution. Create the same for images.
    - We essentially split the data import from the internal format. Can generate our b-trees on the fly.
- Abort the whole idea and see what optimisations are availble in textured tiles.
- develop the ideas around scoring tiles and a hard cap on the number loaded. Useful in many different tile schemes.
- More research into how GoogleMaps or similar will handle the data.

- What are we doing this for? Need to get other items into the environment to compare it with.
    - Add runways, buildings, trees, platforms.
    - Will we want a KoreSim - Mesh library for this, to match the Terrain elements? Be that common thing we instantiate from?

    - First we have the basic meshes we can reference
    - Then we need a godot version of the mesh, then we need to create a located instance of that mesh.

Actions:
- Create better Terrain Elevation/Image classes in KoreSim, so we have an isolated way to get any LLA/Col values from CLI loaded data.
    - Maybe even don't use tilecodes or map library paths here, just raw LLA values, raw paths.
    - Can use it on the triangle meshes - get the LLA of the three positions, average and get.



Ground clamping:
- If we're going to start another pass on the map tiles, maybe reconsider the ground clamps and physics side of things?
    - Enganging with the collision meshes, which may need to mirror the rendered ones?

    - Maybe this needs its own low-poly test project to develop.



Short Term Todo List:
=====================

- Wire MiniMesh into the edit window.
    - Flip triangles
    - OutlineTriangle(s)

- Load a child tile
    - Use a simple camera distance measure for now.
    - Look at more texture disposal ideas, get responsiveness on the dealloc.

- Background task:
    - Determine distance to tile
    - determine vertical and horizontal angles the tile presents, and thus an estimated area.
    - determine an angle to the tile based from the camera position and direction.

    - Create a distance-resolution score of draw priority and resolution, that we can judge against. ie (anything above 50, add the child tiles or next LOD)

- Fine tune the camera movement:
    - Slow down at lower altitudes
    - Don't intersect terrain
    - maybe a better forwards control

- Add some element to an entity
    - the 3D model as an element would be ideal (on the attitude node)
    - Route also.
    - Add an xbox controller input as an element.
    - Have a facility to add and remove them



Bugs:
=====



Future Ideas:
=============
- OSM Data:
    - https://github.com/OsmSharp/core

- FullMesh:
    - Lots of tools and a whole CAD/Blender like app to manage points, lines, surfaces.
    - AutoUV development:
        - put into a separate project (like the mesh decimation) to progress.
    - Primitives:
        - Some ideas, but plan into a test project in the future.

- Consider how we manage a library of objects
    - Actions around rotations, collision, scale.
    - Inject mesh from message?!?
    - Need a purpose to fulfill.
    - We export an ArrayMesh from SurfaceTool into a cache, then assign it to a MeshInstance3D.
        - The detachment (and )

- Coperniucus:
    - Start reading elevation data from the service in the same way that we read images.

- Add messages to be used at a specific simtime, or runtime?
    - A queue within the messaging system (or consumer of it)
        injectat simtime 10 "entity add one"
        injectat runtume 10 "help"
    - Any "injectat runtime" message goes into a time ordered queue/thread, and process the latest one when a time passes.
    - Use a cencptually simple "greater than" rule on the timestamp.

- UV isolation
    - Find groupd of UVs, from material groups, that can be flipped within their BBox.



Comparable Apps/Frameworks:
===========================
- Google Maps

- Google Earth

- KDE Marble
    https://marble.kde.org/

- Caesium
    Expansive 3D world framework and community

- Global Mapper Desktop
    - Map data preparation tool.



Setup
=====

    dotnet add package SharpGLTF.Toolkit



