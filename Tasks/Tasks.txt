
Vision:
=======
A 3D world to explore and visualise customer data.



Target of current iteration:
============================
1 - Define what we want from the application
2 - Deliver tech demos on all the areas.



App Outline
===========
- 3D Globe - Dynamically loading
    - Demos smooth tile loading, minimum VRAM burden
    - New LOD levels, load textures later.
    - New decimated mesh, geometry saved in database.

- Camera controls
    - World view
    - Chase cam

- Entity Data
    - List entities
    - Show pos/speed
    - Show Element summary

- Control
    - Settings
    - Network
    - CLI



Immediate Task (Define a task - focus on delivering it):
=========================================================

Assessment:
- MiniMesh has been very good in defining new options of OBJ/MTL edits with Blender, and then import/export from the code.
- ColorMesh has been very good at defining new minimal surface mesh options. Good mesh creation and serialisation options.

- ColorMesh, plus a number of optimisations around serialisation size and tile creation, does not deliver the required level
  of performance and quality.
    - The RAM usage it too high, even after optimisations. The visual compromise needs to deliver a 100x improvement elsewhere. 
        - Can't just trade VRAM for RAM usage.
    - The step changes in resolution are too high for a consistent aesthetic. This would need a tile-code rework into a b-tree.
        - This is a whole rework of tilecode, map tiles, everything.

Ideas:
- We have an elevation system that can load anything with a range and resolution. Create the same for images.
    - We essentially split the data import from the internal format. Can generate our b-trees on the fly.
- Abort the whole idea and see what optimisations are availble in textured tiles.
- develop the ideas around scoring tiles and a hard cap on the number loaded. Useful in many different tile schemes.
- More research into how GoogleMaps or similar will handle the data.

- What are we doing this for? Need to get other items into the environment to compare it with.
    - Add runways, buildings, trees, platforms.
    - Will we want a KoreSim - Mesh library for this, to match the Terrain elements? Be that common thing we instantiate from?

    - First we have the basic meshes we can reference
    - Then we need a godot version of the mesh, then we need to create a located instance of that mesh.

Actions:
- Create better Terrain Elevation/Image classes in KoreSim, so we have an isolated way to get any LLA/Col values from CLI loaded data.
    - Maybe even don't use tilecodes or map library paths here, just raw LLA values, raw paths.
    - Can use it on the triangle meshes - get the LLA of the three positions, average and get.



Ground clamping:
- If we're going to start another pass on the map tiles, maybe reconsider the ground clamps and physics side of things?
    - Enganging with the collision meshes, which may need to mirror the rendered ones?

    - Maybe this needs its own low-poly test project to develop.



New tile scoring and object organisation:
    - We'll have a budget that can be spent, like 100 objects.
    - Everything is a "scorable object", that will have a ranking.
        - This includes real and potential tiles.
        - Maybe create the scoring itself as a b-tree?
            - Create a visualisation image at the same time? Show off a view frustum and tile layout?

    - Objects generate alloc/dealloc actions based on scores.
        - Dealloc action could maybe regenerate a parent tile?

    - Maybe "only the scoring of child nodes is ever assessed".
        - Avoid the wrenching of mid layer nodes by only building and deconstructing the object layers one by one.

    - So for a lvl0 tile, that we may always want to be present fr full-globe consistency:
        - But we turn visibility off when facing away
        - So visibility and presence/scoring are different.

    KoreScorableObject now exists.
        - We can mechanically select our 100 valid tiles.

A scorable object is a set of tiles, something actioned in one pass.
    - lvl0World is the top level object, creating all lvl0 tiles.

        - lvl1Tileset 
            - A scorable object - say 10.
            - A tilecode, such as Bf
            - A list of subtiles

                - lvl2 tileset
                    - score
                    - tilecode
                    - subtileset

                - 
                - 
                -
                - 



- Maybe each item has two layers
    - Layer of the parent items, the tile resolution
    - Layer of the subtile collections.
    
    - We an create/delete each layer as an action
    - We always want one to be present
        - when the 2 objct is present, we can delete the 1
        - when the 1 is present we can delete the 2
        
        - So we can put the score on the individual tile in the set
    
- Maybe these "data explosions" I'm seeing are a consequence of the 1:25 allocation step changes. There is no way but to allocate 25x more data per step.

- So we go to an inflated cube, with a quad tree split.
    - We need to run an example with the XYZ positions of a cube-face, projected back to LLA, then the A fixed to radius+ele, then back to an XYZ for that point.
    - So we have a cube position, a projected position, then a mesh position, for each 2D index on the cube surface.


  1 | 2  - As oriented from the view of facing the surface from the outside.
  -----
  3 | 4

QuadCubeTileCode
- <Face>:[<Tilecode>] - Example F
- Face is oriented with zeroLL through the middle of the front face. We then have Top, Left, Right, Bottom edged off to that, and Back edged off of right. Frt Top Lft Rgt "Bck" "Bot1321"

QuadCubeTileFactory

    - Each Quad tile will need an rwXYZ anchor point to place it and be scored against.



QuadMeshTiles are working!
- They will rely on resource services around elevation and color to create tiles
- The divisions will not be even, with the pinched corner tiles being smaller than central ones.
    - So we'll need a metric such as meters-per-point to define a consistant geometry per layer. Pinched corner meshes will be different sizes.





Short Term Todo List:
=====================

- Wire MiniMesh into the edit window.
    - Flip triangles
    - OutlineTriangle(s)

- Load a child tile
    - Use a simple camera distance measure for now.
    - Look at more texture disposal ideas, get responsiveness on the dealloc.

- Background task:
    - Determine distance to tile
    - determine vertical and horizontal angles the tile presents, and thus an estimated area.
    - determine an angle to the tile based from the camera position and direction.

    - Create a distance-resolution score of draw priority and resolution, that we can judge against. ie (anything above 50, add the child tiles or next LOD)

- Fine tune the camera movement:
    - Slow down at lower altitudes
    - Don't intersect terrain
    - maybe a better forwards control

- Add some element to an entity
    - the 3D model as an element would be ideal (on the attitude node)
    - Route also.
    - Add an xbox controller input as an element.
    - Have a facility to add and remove them





Bugs:
=====



Future Ideas:
=============
- OSM Data:
    - https://github.com/OsmSharp/core

- FullMesh:
    - Lots of tools and a whole CAD/Blender like app to manage points, lines, surfaces.
    - AutoUV development:
        - put into a separate project (like the mesh decimation) to progress.
    - Primitives:
        - Some ideas, but plan into a test project in the future.

- Consider how we manage a library of objects
    - Actions around rotations, collision, scale.
    - Inject mesh from message?!?
    - Need a purpose to fulfill.
    - We export an ArrayMesh from SurfaceTool into a cache, then assign it to a MeshInstance3D.
        - The detachment (and )

- Coperniucus:
    - Start reading elevation data from the service in the same way that we read images.

- Add messages to be used at a specific simtime, or runtime?
    - A queue within the messaging system (or consumer of it)
        injectat simtime 10 "entity add one"
        injectat runtume 10 "help"
    - Any "injectat runtime" message goes into a time ordered queue/thread, and process the latest one when a time passes.
    - Use a cencptually simple "greater than" rule on the timestamp.

- UV isolation
    - Find groupd of UVs, from material groups, that can be flipped within their BBox.



Comparable Apps/Frameworks:
===========================
- Google Maps

- Google Earth

- KDE Marble
    https://marble.kde.org/

- Caesium
    Expansive 3D world framework and community

- Global Mapper Desktop
    - Map data preparation tool.



Setup
=====

    dotnet add package SharpGLTF.Toolkit



